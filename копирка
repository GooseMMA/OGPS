import sys
import json
import time
import threading
import ctypes
from ctypes import wintypes
from pathlib import Path
from PyQt5 import QtWidgets, QtCore
from pynput import keyboard as pkb

# ---------------- WinAPI setup ----------------
user32 = ctypes.windll.user32
EnumWindows = user32.EnumWindows
EnumWindowsProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM)
IsWindowVisible = user32.IsWindowVisible
GetWindowTextW = user32.GetWindowTextW
GetWindowTextLengthW = user32.GetWindowTextLengthW
ScreenToClient = user32.ScreenToClient
PostMessageW = user32.PostMessageW

WM_LBUTTONDOWN = 0x0201
WM_LBUTTONUP = 0x0202

# ---------------- Helper funcs ----------------
def enum_windows():
    results = []
    def callback(hwnd, lParam):
        if IsWindowVisible(hwnd):
            length = GetWindowTextLengthW(hwnd)
            if length > 0:
                buff = ctypes.create_unicode_buffer(length + 1)
                GetWindowTextW(hwnd, buff, length + 1)
                title = buff.value
                if title.strip():
                    results.append((hwnd, title))
        return True
    EnumWindows(EnumWindowsProc(callback), 0)
    return results

def make_lparam(x, y):
    return (y << 16) | (x & 0xFFFF)

def post_click(hwnd, x, y):
    lparam = make_lparam(x, y)
    PostMessageW(hwnd, WM_LBUTTONDOWN, 1, lparam)
    time.sleep(0.01)
    PostMessageW(hwnd, WM_LBUTTONUP, 0, lparam)

# ---------------- Settings ----------------
SETTINGS_PATH = Path("settings.json")

def load_settings():
    if SETTINGS_PATH.exists():
        try:
            return json.loads(SETTINGS_PATH.read_text(encoding="utf-8"))
        except:
            pass
    return {"interval_ms": 200, "hotkey": "", "target_title": "", "click_point": [0, 0]}

def save_settings(s):
    SETTINGS_PATH.write_text(json.dumps(s, indent=2, ensure_ascii=False), encoding="utf-8")

# ---------------- Clicker thread ----------------
class ClickerThread(threading.Thread):
    def __init__(self, hwnd, point, interval):
        super().__init__(daemon=True)
        self.hwnd = hwnd
        self.point = point
        self.interval = interval / 1000.0
        self._stop = threading.Event()

    def stop(self):
        self._stop.set()

    def run(self):
        while not self._stop.is_set():
            post_click(self.hwnd, self.point[0], self.point[1])
            time.sleep(self.interval)

# ---------------- GUI ----------------
class AutoClicker(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Window-bound AutoClicker (minimal)")
        self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        self.clicker = None
        self.hotkey = ""
        self.hwnd = None
        self.click_point = [0, 0]
        self.settings = load_settings()

        self.layout = QtWidgets.QVBoxLayout(self)

        # Window select
        h1 = QtWidgets.QHBoxLayout()
        self.win_combo = QtWidgets.QComboBox()
        self.refresh_btn = QtWidgets.QPushButton("Refresh")
        self.refresh_btn.clicked.connect(self.refresh_windows)
        h1.addWidget(QtWidgets.QLabel("Select window:"))
        h1.addWidget(self.win_combo)
        h1.addWidget(self.refresh_btn)
        self.layout.addLayout(h1)

        # Pick point
        h2 = QtWidgets.QHBoxLayout()
        self.pick_btn = QtWidgets.QPushButton("Pick point")
        self.pick_btn.clicked.connect(self.pick_point)
        self.coord_label = QtWidgets.QLabel("X=0, Y=0")
        h2.addWidget(self.pick_btn)
        h2.addWidget(self.coord_label)
        self.layout.addLayout(h2)

        # Interval
        h3 = QtWidgets.QHBoxLayout()
        self.interval_spin = QtWidgets.QSpinBox()
        self.interval_spin.setRange(1, 10000)
        self.interval_spin.setValue(self.settings.get("interval_ms", 200))
        h3.addWidget(QtWidgets.QLabel("Interval (ms):"))
        h3.addWidget(self.interval_spin)
        self.layout.addLayout(h3)

        # Hotkey
        h4 = QtWidgets.QHBoxLayout()
        self.hotkey_label = QtWidgets.QLineEdit()
        self.hotkey_label.setReadOnly(True)
        self.record_hotkey_btn = QtWidgets.QPushButton("Record Hotkey")
        self.record_hotkey_btn.clicked.connect(self.record_hotkey)
        h4.addWidget(QtWidgets.QLabel("Hotkey:"))
        h4.addWidget(self.hotkey_label)
        h4.addWidget(self.record_hotkey_btn)
        self.layout.addLayout(h4)

        # Start / stop
        self.start_btn = QtWidgets.QPushButton("Start")
        self.stop_btn = QtWidgets.QPushButton("Stop")
        self.stop_btn.setEnabled(False)
        self.start_btn.clicked.connect(self.start_clicker)
        self.stop_btn.clicked.connect(self.stop_clicker)
        h5 = QtWidgets.QHBoxLayout()
        h5.addWidget(self.start_btn)
        h5.addWidget(self.stop_btn)
        self.layout.addLayout(h5)

        self.refresh_windows()
        self.load_from_settings()
        self.start_hotkey_listener()

    def refresh_windows(self):
        self.win_combo.clear()
        for hwnd, title in enum_windows():
            self.win_combo.addItem(title, int(hwnd))

    def pick_point(self):
        QtWidgets.QMessageBox.information(self, "Pick point", "Наведите курсор и нажмите Shift+P на точке.")
        self.listener = pkb.Listener(on_press=self._pick_point_key)
        self.listener.start()

    def _pick_point_key(self, key):
        if key == pkb.KeyCode.from_char('p') and any([
            pkb.Controller().pressed_keys and pkb.Key.shift in pkb.Controller().pressed_keys
        ]):
            pt = wintypes.POINT()
            user32.GetCursorPos(ctypes.byref(pt))
            hwnd = self.win_combo.currentData()
            if not hwnd:
                return False
            client_pt = wintypes.POINT(pt.x, pt.y)
            ScreenToClient(hwnd, ctypes.byref(client_pt))
            self.click_point = [client_pt.x, client_pt.y]
            self.coord_label.setText(f"X={client_pt.x}, Y={client_pt.y}")
            self.listener.stop()
            return False
        return True

    def record_hotkey(self):
        QtWidgets.QMessageBox.information(self, "Hotkey", "Нажмите клавишу для включения/выключения.")
        captured = {"done": False}
        def on_key(key):
            if captured["done"]:
                return False
            self.hotkey = str(key)
            self.hotkey_label.setText(self.hotkey)
            captured["done"] = True
            return False
        listener = pkb.Listener(on_press=on_key)
        listener.start()
        threading.Thread(target=lambda: (listener.join(), self.start_hotkey_listener()), daemon=True).start()

    def start_hotkey_listener(self):
        def on_press(key):
            if str(key) == self.hotkey:
                self.toggle_clicker()
        listener = pkb.Listener(on_press=on_press)
        listener.start()

    def toggle_clicker(self):
        if self.clicker:
            self.stop_clicker()
        else:
            self.start_clicker()

    def start_clicker(self):
        hwnd = self.win_combo.currentData()
        if not hwnd or self.click_point == [0, 0]:
            QtWidgets.QMessageBox.warning(self, "Error", "Выберите окно и точку.")
            return
        interval = self.interval_spin.value()
        self.clicker = ClickerThread(hwnd, self.click_point, interval)
        self.clicker.start()
        self.start_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.save_settings()

    def stop_clicker(self):
        if self.clicker:
            self.clicker.stop()
            self.clicker = None
        self.start_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.save_settings()

    def save_settings(self):
        s = {
            "interval_ms": self.interval_spin.value(),
            "hotkey": self.hotkey,
            "target_title": self.win_combo.currentText(),
            "click_point": self.click_point
        }
        save_settings(s)

    def load_from_settings(self):
        s = self.settings
        title = s.get("target_title", "")
        idx = self.win_combo.findText(title)
        if idx >= 0:
            self.win_combo.setCurrentIndex(idx)
        self.hotkey = s.get("hotkey", "")
        self.hotkey_label.setText(self.hotkey)
        self.click_point = s.get("click_point", [0, 0])
        self.coord_label.setText(f"X={self.click_point[0]}, Y={self.click_point[1]}")

# ---------------- Run ----------------
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    w = AutoClicker()
    w.show()
    sys.exit(app.exec_())