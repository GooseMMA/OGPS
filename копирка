# gamehelper_v3.py
"""
GameHelper v3 - Prototype (single-file)
- Windows-only
- PyQt5 GUI, dark theme, hamburger menu, welcome screen
- Window-bound clicker with pick-point overlay (crosshair)
- Simple clicker (click at cursor)
- HUD mini-panel (draggable, adjustable opacity), position saved
- Profiles saved in %APPDATA%\GameHelperConfigs\window and ...\simple
- Global hotkey recording (keyboard or mouse) via pynput
- Python-generated sounds via winsound.Beep (start/stop)
- Dependencies: pyqt5, pynput, pyautogui
"""
import sys, os, json, time, threading, ctypes
from ctypes import wintypes
from pathlib import Path

from PyQt5 import QtWidgets, QtCore, QtGui
import pyautogui
from pynput import keyboard as pynput_keyboard, mouse as pynput_mouse

# ---------- WinAPI helpers ----------
user32 = ctypes.windll.user32
EnumWindows = user32.EnumWindows
EnumWindowsProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HWND, wintypes.LPARAM)
IsWindowVisible = user32.IsWindowVisible
GetWindowTextW = user32.GetWindowTextW
GetWindowTextLengthW = user32.GetWindowTextLengthW
ScreenToClient = user32.ScreenToClient
PostMessageW = user32.PostMessageW
HWND = wintypes.HWND
WM_LBUTTONDOWN = 0x0201
WM_LBUTTONUP = 0x0202

def enum_windows():
    results = []
    def _cb(hwnd, lParam):
        if IsWindowVisible(hwnd):
            length = GetWindowTextLengthW(hwnd)
            if length > 0:
                buff = ctypes.create_unicode_buffer(length + 1)
                GetWindowTextW(hwnd, buff, length + 1)
                title = buff.value
                if title.strip():
                    results.append((int(hwnd), title))
        return True
    EnumWindows(EnumWindowsProc(_cb), 0)
    return results

def make_lparam(x, y):
    return (y << 16) | (x & 0xFFFF)

def post_left_click(hwnd, x, y):
    try:
        lparam = make_lparam(int(x), int(y))
        PostMessageW(HWND(int(hwnd)), WM_LBUTTONDOWN, 1, lparam)
        time.sleep(0.01)
        PostMessageW(HWND(int(hwnd)), WM_LBUTTONUP, 0, lparam)
    except Exception as e:
        print("post_left_click error:", e)

def screen_to_client(hwnd, sx, sy):
    pt = wintypes.POINT(int(sx), int(sy))
    ScreenToClient(HWND(int(hwnd)), ctypes.byref(pt))
    return (pt.x, pt.y)

# ---------- Config paths ----------
APPDATA = os.getenv("APPDATA") or str(Path.home())
BASE_CONFIG_DIR = Path(APPDATA) / "GameHelperConfigs"
WINDOW_DIR = BASE_CONFIG_DIR / "window"
SIMPLE_DIR = BASE_CONFIG_DIR / "simple"
BASE_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
WINDOW_DIR.mkdir(parents=True, exist_ok=True)
SIMPLE_DIR.mkdir(parents=True, exist_ok=True)
USER_SETTINGS = BASE_CONFIG_DIR / "user_settings.json"
LAST_WINDOW_FILE = BASE_CONFIG_DIR / "last_window.json"
LAST_SIMPLE_FILE = BASE_CONFIG_DIR / "last_simple.json"

def load_json(p, default):
    try:
        if Path(p).exists():
            return json.loads(Path(p).read_text(encoding="utf-8"))
    except Exception:
        pass
    return default

def save_json(p, data):
    Path(p).write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")

# ---------- Global signals ----------
class GlobalSignals(QtCore.QObject):
    picked = QtCore.pyqtSignal(int, int)   # client coords
    hotkey = QtCore.pyqtSignal(str)        # binding
global_signals = GlobalSignals()

# ---------- Simple sound (winsound) ----------
def play_start_sound(enabled=True):
    if not enabled: return
    try:
        import winsound
        # simple beep pattern: short-high, short-low
        winsound.Beep(1200, 80)
    except Exception:
        pass

def play_stop_sound(enabled=True):
    if not enabled: return
    try:
        import winsound
        winsound.Beep(700, 80)
    except Exception:
        pass

# ---------- Clicker threads ----------
class SimpleClickerThread(threading.Thread):
    def __init__(self, interval_ms):
        super().__init__(daemon=True)
        self.interval = max(1, int(interval_ms)) / 1000.0
        self._stop = threading.Event()
        self.clicks_done = 0
        self.start_time = None

    def stop(self):
        self._stop.set()

    def run(self):
        self.start_time = time.time()
        while not self._stop.is_set():
            try:
                pyautogui.click()
                self.clicks_done += 1
            except Exception as e:
                print("SimpleClicker:", e)
            time.sleep(self.interval)

class WindowClickerThread(threading.Thread):
    def __init__(self, hwnd, point, interval_ms):
        super().__init__(daemon=True)
        self.hwnd = int(hwnd)
        self.point = (int(point[0]), int(point[1]))
        self.interval = max(1, int(interval_ms)) / 1000.0
        self._stop = threading.Event()
        self.clicks_done = 0
        self.start_time = None

    def stop(self):
        self._stop.set()

    def run(self):
        self.start_time = time.time()
        while not self._stop.is_set():
            try:
                post_left_click(self.hwnd, self.point[0], self.point[1])
                self.clicks_done += 1
            except Exception as e:
                print("WindowClicker:", e)
            time.sleep(self.interval)

# ---------- Profiles helpers ----------
def list_profiles(mode):
    d = WINDOW_DIR if mode=="window" else SIMPLE_DIR
    return [p.stem for p in sorted(d.glob("*.json"))]

def save_profile(mode, name, data):
    d = WINDOW_DIR if mode=="window" else SIMPLE_DIR
    p = d / f"{name}.json"
    p.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")

def load_profile(mode, name):
    d = WINDOW_DIR if mode=="window" else SIMPLE_DIR
    p = d / f"{name}.json"
    if p.exists():
        return json.loads(p.read_text(encoding="utf-8"))
    return None

def delete_profile(mode, name):
    d = WINDOW_DIR if mode=="window" else SIMPLE_DIR
    p = d / f"{name}.json"
    if p.exists():
        p.unlink()

# ---------- UI components ----------
class CrosshairOverlay(QtWidgets.QWidget):
    clicked = QtCore.pyqtSignal(int, int)  # screen coords

    def __init__(self):
        super().__init__(None, QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        self.setWindowState(self.windowState() | QtCore.Qt.WindowFullScreen)
        self.setCursor(QtGui.QCursor(QtCore.Qt.CrossCursor))
        self.mx = None; self.my = None
        self.pen = QtGui.QPen(QtGui.QColor(255,80,80,220), 2)
        # capture mouse events
        self.setMouseTracking(True)

    def mouseMoveEvent(self, ev):
        self.mx = ev.globalX(); self.my = ev.globalY(); self.update()

    def mousePressEvent(self, ev):
        if ev.button() == QtCore.Qt.LeftButton:
            self.clicked.emit(ev.globalX(), ev.globalY())
            self.close()

    def paintEvent(self, ev):
        if self.mx is None or self.my is None: return
        p = QtGui.QPainter(self)
        p.setRenderHint(QtGui.QPainter.Antialiasing)
        p.setPen(self.pen)
        s = 18
        p.drawLine(self.mx - s, self.my, self.mx + s, self.my)
        p.drawLine(self.mx, self.my - s, self.mx, self.my + s)
        p.setBrush(QtGui.QColor(255,80,80,200))
        p.drawEllipse(QtCore.QPoint(self.mx, self.my), 4, 4)
        p.end()

class ProfilesDialog(QtWidgets.QDialog):
    def __init__(self, mode, parent=None, title="Profiles"):
        super().__init__(parent)
        self.mode = mode
        self.setWindowTitle(title)
        self.resize(420, 320)
        v = QtWidgets.QVBoxLayout(self)
        v.addWidget(QtWidgets.QLabel("Select profile:"))
        self.listw = QtWidgets.QListWidget(); v.addWidget(self.listw)
        h = QtWidgets.QHBoxLayout()
        self.ok = QtWidgets.QPushButton("OK"); self.cancel = QtWidgets.QPushButton("Cancel")
        h.addWidget(self.ok); h.addWidget(self.cancel); v.addLayout(h)
        self.ok.clicked.connect(self.accept); self.cancel.clicked.connect(self.reject)
        self.populate()

    def populate(self):
        self.listw.clear()
        for n in list_profiles(self.mode):
            self.listw.addItem(n)

    def selected(self):
        it = self.listw.currentItem()
        return it.text() if it else None

# ---------- HUD mini-panel ----------
class HudWindow(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super().__init__(parent, QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint)
        self.setWindowTitle("HUD")
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        self.setWindowFlags(self.windowFlags() | QtCore.Qt.Tool)
        self.setFixedSize(220, 70)
        self.opacity = 0.85
        self.setWindowOpacity(self.opacity)
        self.is_dragging = False
        self.offset = QtCore.QPoint(0,0)
        self.running = False
        self.mode = "None"
        self.session_start = None
        self.hotkey = ""
        self._build_ui()

    def _build_ui(self):
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(8,8,8,8)
        self.lbl_mode = QtWidgets.QLabel("Mode: -")
        self.lbl_status = QtWidgets.QLabel("Status: Stopped")
        self.lbl_time = QtWidgets.QLabel("Time: 00:00:00")
        for lbl in (self.lbl_mode, self.lbl_status, self.lbl_time):
            lbl.setStyleSheet("color: #e8eef8; font-size:11px;")
        layout.addWidget(self.lbl_mode)
        layout.addWidget(self.lbl_status)
        layout.addWidget(self.lbl_time)
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self._update_time)
        self.timer.start(500)

    def mousePressEvent(self, ev):
        if ev.button() == QtCore.Qt.LeftButton:
            self.is_dragging = True
            self.offset = ev.globalPos() - self.pos()

    def mouseMoveEvent(self, ev):
        if self.is_dragging:
            self.move(ev.globalPos() - self.offset)

    def mouseReleaseEvent(self, ev):
        self.is_dragging = False

    def set_running(self, running, mode="None"):
        self.running = running
        self.mode = mode
        if running:
            self.session_start = time.time()
            self.lbl_status.setText("Status: Running")
            self.lbl_mode.setText(f"Mode: {mode}")
        else:
            self.lbl_status.setText("Status: Stopped")
        # save position & opacity externally

    def _update_time(self):
        if self.running and self.session_start:
            s = int(time.time() - self.session_start)
            h = s//3600; m = (s%3600)//60; sec = s%60
            self.lbl_time.setText(f"Time: {h:02d}:{m:02d}:{sec:02d}")

# ---------- Main widgets ----------
class MainScreen(QtWidgets.QWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self._build_ui()

    def _build_ui(self):
        v = QtWidgets.QVBoxLayout(self)
        v.setContentsMargins(24,24,24,24)
        title = QtWidgets.QLabel("GameHelper v3")
        title.setObjectName("title")
        title.setAlignment(QtCore.Qt.AlignCenter)
        font = QtGui.QFont("Roboto", 24, QtGui.QFont.Bold)
        title.setFont(font)
        subtitle = QtWidgets.QLabel("Precision Autoclicker — modular & beautiful")
        subtitle.setAlignment(QtCore.Qt.AlignCenter)
        btns = QtWidgets.QHBoxLayout()
        wbtn = QtWidgets.QPushButton("Window Clicker"); sbtn = QtWidgets.QPushButton("Simple Clicker")
        wbtn.clicked.connect(lambda: self.parent().switch_to("window"))
        sbtn.clicked.connect(lambda: self.parent().switch_to("simple"))
        settings_btn = QtWidgets.QPushButton("Settings")
        settings_btn.clicked.connect(lambda: self.parent().switch_to("settings"))
        for b in (wbtn, sbtn, settings_btn):
            b.setFixedWidth(180)
        btns.addStretch(); btns.addWidget(wbtn); btns.addSpacing(14); btns.addWidget(sbtn); btns.addSpacing(14); btns.addWidget(settings_btn); btns.addStretch()
        v.addStretch(); v.addWidget(title); v.addWidget(subtitle); v.addSpacing(18); v.addLayout(btns); v.addStretch()
    def paintEvent(self, ev):
        qp = QtGui.QPainter(self)
        grad = QtGui.QLinearGradient(0,0,self.width(),self.height())
        grad.setColorAt(0, QtGui.QColor(18,10,36))
        grad.setColorAt(1, QtGui.QColor(6,6,12))
        qp.fillRect(self.rect(), grad)
        qp.end()

class WindowClickerWidget(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.clicker = None
        self.picked_point = (0,0)
        self.hotkey_binding = ""
        self._hotstop = None
        self._build_ui()
        global_signals.picked.connect(self._on_picked)
        global_signals.hotkey.connect(self._on_hotkey)
        self.refresh_windows()
        self._load_last()

    def _build_ui(self):
        v = QtWidgets.QVBoxLayout(self)
        header = QtWidgets.QHBoxLayout()
        header.addWidget(QtWidgets.QLabel("<b>Window Clicker</b>"))
        header.addStretch()
        header_btn = QtWidgets.QPushButton("Create HUD")
        header_btn.clicked.connect(self.parent().create_hud_if_needed)
        header.addWidget(header_btn)
        v.addLayout(header)

        # window selection
        row1 = QtWidgets.QHBoxLayout()
        self.win_combo = QtWidgets.QComboBox(); self.win_combo.setMinimumWidth(400)
        row1.addWidget(QtWidgets.QLabel("Target window:")); row1.addWidget(self.win_combo)
        v.addLayout(row1)

        row2 = QtWidgets.QHBoxLayout()
        self.btn_refresh = QtWidgets.QPushButton("Refresh windows"); self.btn_refresh.clicked.connect(self.refresh_windows)
        self.btn_pick = QtWidgets.QPushButton("Pick point (click on screen)"); self.btn_pick.clicked.connect(self.start_pick)
        self.coord_label = QtWidgets.QLabel("X=0, Y=0")
        row2.addWidget(self.btn_refresh); row2.addWidget(self.btn_pick); row2.addWidget(self.coord_label); row2.addStretch()
        v.addLayout(row2)

        row3 = QtWidgets.QHBoxLayout()
        self.interval_edit = QtWidgets.QLineEdit("200"); self.interval_edit.setFixedWidth(120)
        row3.addWidget(QtWidgets.QLabel("Interval (ms):")); row3.addWidget(self.interval_edit)
        self.hot_label = QtWidgets.QLineEdit(""); self.hot_label.setReadOnly(True); self.hot_label.setFixedWidth(220)
        self.btn_record = QtWidgets.QPushButton("Record hotkey"); self.btn_record.clicked.connect(self.record_hotkey)
        row3.addWidget(QtWidgets.QLabel("Hotkey:")); row3.addWidget(self.hot_label); row3.addWidget(self.btn_record)
        v.addLayout(row3)

        row4 = QtWidgets.QHBoxLayout()
        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_stop = QtWidgets.QPushButton("Stop"); self.btn_stop.setEnabled(False)
        self.btn_start.clicked.connect(self.start_clicker); self.btn_stop.clicked.connect(self.stop_clicker)
        self.btn_save = QtWidgets.QPushButton("Save cfg"); self.btn_load = QtWidgets.QPushButton("Load cfg"); self.btn_del = QtWidgets.QPushButton("Delete cfg")
        self.btn_save.clicked.connect(self.save_cfg); self.btn_load.clicked.connect(self.load_cfg); self.btn_del.clicked.connect(self.delete_cfg)
        row4.addWidget(self.btn_start); row4.addWidget(self.btn_stop); row4.addStretch(); row4.addWidget(self.btn_save); row4.addWidget(self.btn_load); row4.addWidget(self.btn_del)
        v.addLayout(row4)

        v.addWidget(QtWidgets.QLabel("Profiles:"))
        self.profiles_list = QtWidgets.QListWidget(); v.addWidget(self.profiles_list)

        v.addWidget(QtWidgets.QLabel("Log:"))
        self.log = QtWidgets.QPlainTextEdit(); self.log.setReadOnly(True); self.log.setMaximumHeight(160); v.addWidget(self.log)

    def log_msg(self, s):
        self.log.appendPlainText(f"[{time.strftime('%H:%M:%S')}] {s}")

    def refresh_windows(self):
        self.win_combo.clear()
        self.win_combo.addItem("(none)", 0)
        try:
            for hwnd, title in enum_windows():
                self.win_combo.addItem(title, hwnd)
            self.log_msg("Window list refreshed")
        except Exception as e:
            self.log_msg("Refresh error: "+str(e))

    def start_pick(self):
        idx = self.win_combo.currentIndex()
        if idx <= 0:
            QtWidgets.QMessageBox.warning(self, "Pick", "Select target window first.")
            return
        self.btn_pick.setEnabled(False)
        overlay = CrosshairOverlay()
        def on_click(sx, sy):
            try:
                hwnd = int(self.win_combo.currentData())
                cx, cy = screen_to_client(hwnd, sx, sy)
                global_signals.picked.emit(cx, cy)
            except Exception as e:
                self.log_msg("Pick error: "+str(e))
            overlay.close()
            self.btn_pick.setEnabled(True)
        overlay.clicked.connect(on_click)
        overlay.showFullScreen()
        overlay.activateWindow()
        overlay.raise_()

    @QtCore.pyqtSlot(int, int)
    def _on_picked(self, x, y):
        self.picked_point = (x, y)
        self.coord_label.setText(f"X={x}, Y={y}")
        self.log_msg(f"Picked point {x},{y}")

    # hotkey record
    def record_hotkey(self):
        self.hot_label.setText("НАЖМИТЕ КНОПКУ...")
        self.btn_record.setEnabled(False)
        t = threading.Thread(target=self._hot_record_thread, daemon=True); t.start()

    def _hot_record_thread(self):
        captured = {"done": False}
        res = {"type": None, "val": None}
        def on_k(key):
            if captured["done"]: return False
            try:
                name = key.char if hasattr(key, "char") and key.char else str(key).split(".")[-1]
                res["type"]="key"; res["val"]=name; captured["done"]=True; return False
            except: return False
        def on_m(x,y,button,pressed):
            if captured["done"] or not pressed: return False
            res["type"]="mouse"; res["val"]=str(button).split(".")[-1]; captured["done"]=True; return False
        kb = pynput_keyboard.Listener(on_press=on_k); ms = pynput_mouse.Listener(on_click=on_m)
        kb.start(); ms.start()
        while not captured["done"]:
            time.sleep(0.01)
        try: kb.stop(); ms.stop()
        except: pass
        friendly = f"{res['type']}:{res['val']}"
        global_signals.hotkey.emit(friendly)
        QtCore.QMetaObject.invokeMethod(self, "_enable_record", QtCore.Qt.QueuedConnection)

    @QtCore.pyqtSlot()
    def _enable_record(self):
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_hotkey(self, s):
        self.hotkey_binding = s
        self.hot_label.setText(s)
        self.log_msg("Hotkey recorded: "+s)
        self._start_hot_listener()

    def _start_hot_listener(self):
        if getattr(self, "_hotstop", None):
            self._hotstop.set()
        self._hotstop = threading.Event()
        def listener():
            stop_event = self._hotstop
            if not getattr(self, "hotkey_binding", ""): return
            btype, bval = self.hotkey_binding.split(":",1)
            def on_k(key):
                if stop_event.is_set(): return False
                try:
                    name = key.char if hasattr(key, "char") and key.char else str(key).split(".")[-1]
                    if btype=="key" and name==bval:
                        QtCore.QMetaObject.invokeMethod(self, "_toggle_start_stop", QtCore.Qt.QueuedConnection)
                except: pass
            def on_m(x,y,button,pressed):
                if stop_event.is_set(): return False
                if not pressed: return
                if btype=="mouse" and str(button).split(".")[-1]==bval:
                    QtCore.QMetaObject.invokeMethod(self, "_toggle_start_stop", QtCore.Qt.QueuedConnection)
            kb = pynput_keyboard.Listener(on_press=on_k); ms = pynput_mouse.Listener(on_click=on_m)
            kb.start(); ms.start()
            while not stop_event.is_set():
                time.sleep(0.1)
            try: kb.stop(); ms.stop()
            except: pass
        threading.Thread(target=listener, daemon=True).start()

    @QtCore.pyqtSlot()
    def _toggle_start_stop(self):
        if self.btn_start.isEnabled(): self.start_clicker()
        else: self.stop_clicker()

    def start_clicker(self):
        idx = self.win_combo.currentIndex()
        if idx <= 0:
            QtWidgets.QMessageBox.warning(self, "Start", "Select target window.")
            return
        hwnd = int(self.win_combo.currentData())
        if not hasattr(self, "picked_point") or self.picked_point==(0,0):
            QtWidgets.QMessageBox.warning(self, "Start", "Pick a point first.")
            return
        try:
            interval = int(self.interval_edit.text())
            if interval < 1: raise ValueError()
        except:
            QtWidgets.QMessageBox.warning(self, "Start", "Interval must be integer >=1")
            return
        # start thread
        self.clicker = WindowClickerThread(hwnd, self.picked_point, interval)
        self.clicker.start()
        self.btn_start.setEnabled(False); self.btn_stop.setEnabled(True)
        self.log_msg("Window clicker started")
        # sound
        play_start_sound(self.parent().settings.get("sounds_enabled", True))
        # save last
        last = {"interval_ms": interval, "hotkey": getattr(self, "hotkey_binding", ""), "target_title": self.win_combo.currentText(), "click_point": list(self.picked_point)}
        save_json(LAST_WINDOW_FILE, last)
        # update HUD if present
        if self.parent().hud:
            self.parent().hud.set_running(True, "Window")

    def stop_clicker(self):
        if self.clicker:
            self.clicker.stop(); self.clicker = None
        self.btn_start.setEnabled(True); self.btn_stop.setEnabled(False)
        self.log_msg("Window clicker stopped")
        play_stop_sound(self.parent().settings.get("sounds_enabled", True))
        if self.parent().hud:
            self.parent().hud.set_running(False)

    # profiles
    def refresh_profiles_list(self):
        self.profiles_list.clear()
        for n in list_profiles("window"):
            self.profiles_list.addItem(n)

    def save_cfg(self):
        name, ok = QtWidgets.QInputDialog.getText(self, "Save profile", "Profile name:")
        if not ok or not name.strip(): return
        data = {"interval_ms": int(self.interval_edit.text()), "hotkey": getattr(self, "hotkey_binding", ""), "target_title": self.win_combo.currentText(), "click_point": list(getattr(self, "picked_point", (0,0)))}
        save_profile("window", name.strip(), data)
        self.log_msg("Saved profile "+name.strip()); self.refresh_profiles_list()

    def load_cfg(self):
        dlg = ProfilesDialog("window", self, title="Load profile")
        if dlg.exec_() != QtWidgets.QDialog.Accepted: return
        name = dlg.selected()
        if not name: QtWidgets.QMessageBox.information(self, "Load", "No profile selected"); return
        data = load_profile("window", name)
        if not data: QtWidgets.QMessageBox.warning(self, "Load", "Failed to load"); return
        self.interval_edit.setText(str(data.get("interval_ms", 200)))
        self.hotkey_binding = data.get("hotkey", ""); self.hot_label.setText(self.hotkey_binding)
        self.picked_point = tuple(data.get("click_point", (0,0))); self.coord_label.setText(f"X={self.picked_point[0]}, Y={self.picked_point[1]}")
        title = data.get("target_title", "")
        if title:
            idx = self.win_combo.findText(title)
            if idx >= 0: self.win_combo.setCurrentIndex(idx)
        self.log_msg("Loaded profile "+name)
        self._start_hot_listener(); self.refresh_profiles_list()

    def delete_cfg(self):
        dlg = ProfilesDialog("window", self, title="Delete profile")
        if dlg.exec_() != QtWidgets.QDialog.Accepted: return
        name = dlg.selected()
        if not name: QtWidgets.QMessageBox.information(self, "Delete", "No profile selected"); return
        delete_profile("window", name); self.log_msg("Deleted profile "+name); self.refresh_profiles_list()

    def _on_picked(self, x, y):
        self.picked_point = (x, y)
        self.coord_label.setText(f"X={x}, Y={y}")
        self.log_msg(f"Picked point {x},{y}")

    def _on_hotkey(self, s):
        self.hotkey_binding = s
        self.hot_label.setText(s)
        self.log_msg("Hotkey recorded: "+s)
        self._start_hot_listener()

    def _load_last(self):
        last = load_json(LAST_WINDOW_FILE, {})
        if last:
            try:
                self.interval_edit.setText(str(last.get("interval_ms", 200)))
                self.hotkey_binding = last.get("hotkey", ""); self.hot_label.setText(self.hotkey_binding)
                self.picked_point = tuple(last.get("click_point", (0,0))); self.coord_label.setText(f"X={self.picked_point[0]}, Y={self.picked_point[1]}")
                title = last.get("target_title", "")
                if title:
                    idx = self.win_combo.findText(title)
                    if idx >= 0: self.win_combo.setCurrentIndex(idx)
            except: pass

class SimpleClickerWidget(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.clicker = None
        self.hotkey_binding = ""
        self._hotstop = None
        self._build_ui()
        global_signals.hotkey.connect(self._on_hotkey)
        self.refresh_profiles_list()
        self._load_last()

    def _build_ui(self):
        v = QtWidgets.QVBoxLayout(self)
        header = QtWidgets.QHBoxLayout()
        header.addWidget(QtWidgets.QLabel("<b>Simple Clicker</b>"))
        header.addStretch()
        v.addLayout(header)

        row1 = QtWidgets.QHBoxLayout()
        self.interval_edit = QtWidgets.QLineEdit("200"); self.interval_edit.setFixedWidth(120)
        row1.addWidget(QtWidgets.QLabel("Interval (ms):")); row1.addWidget(self.interval_edit)
        self.hot_label = QtWidgets.QLineEdit(""); self.hot_label.setReadOnly(True); self.hot_label.setFixedWidth(220)
        self.btn_record = QtWidgets.QPushButton("Record hotkey"); self.btn_record.clicked.connect(self.record_hotkey)
        row1.addWidget(QtWidgets.QLabel("Hotkey:")); row1.addWidget(self.hot_label); row1.addWidget(self.btn_record)
        v.addLayout(row1)

        row2 = QtWidgets.QHBoxLayout()
        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_stop = QtWidgets.QPushButton("Stop"); self.btn_stop.setEnabled(False)
        self.btn_start.clicked.connect(self.start_clicker); self.btn_stop.clicked.connect(self.stop_clicker)
        self.btn_save = QtWidgets.QPushButton("Save cfg"); self.btn_load = QtWidgets.QPushButton("Load cfg"); self.btn_del = QtWidgets.QPushButton("Delete cfg")
        self.btn_save.clicked.connect(self.save_cfg); self.btn_load.clicked.connect(self.load_cfg); self.btn_del.clicked.connect(self.delete_cfg)
        row2.addWidget(self.btn_start); row2.addWidget(self.btn_stop); row2.addStretch(); row2.addWidget(self.btn_save); row2.addWidget(self.btn_load); row2.addWidget(self.btn_del)
        v.addLayout(row2)

        v.addWidget(QtWidgets.QLabel("Profiles:"))
        self.profiles_list = QtWidgets.QListWidget(); v.addWidget(self.profiles_list)

        v.addWidget(QtWidgets.QLabel("Log:"))
        self.log = QtWidgets.QPlainTextEdit(); self.log.setReadOnly(True); self.log.setMaximumHeight(160); v.addWidget(self.log)

    def log_msg(self, s):
        self.log.appendPlainText(f"[{time.strftime('%H:%M:%S')}] {s}")

    def record_hotkey(self):
        self.hot_label.setText("НАЖМИТЕ КНОПКУ...")
        self.btn_record.setEnabled(False)
        t = threading.Thread(target=self._hot_record, daemon=True); t.start()

    def _hot_record(self):
        captured = {"done": False}
        res = {"type": None, "val": None}
        def on_k(key):
            if captured["done"]: return False
            try:
                name = key.char if hasattr(key, "char") and key.char else str(key).split(".")[-1]
                res["type"]="key"; res["val"]=name; captured["done"]=True; return False
            except: return False
        def on_m(x,y,button,pressed):
            if captured["done"] or not pressed: return False
            res["type"]="mouse"; res["val"]=str(button).split(".")[-1]; captured["done"]=True; return False
        kb = pynput_keyboard.Listener(on_press=on_k); ms = pynput_mouse.Listener(on_click=on_m)
        kb.start(); ms.start()
        while not captured["done"]:
            time.sleep(0.01)
        try: kb.stop(); ms.stop()
        except: pass
        friendly = f"{res['type']}:{res['val']}"
        global_signals.hotkey.emit(friendly)
        QtCore.QMetaObject.invokeMethod(self, "_enable_record", QtCore.Qt.QueuedConnection)

    @QtCore.pyqtSlot()
    def _enable_record(self):
        self.btn_record.setEnabled(True)

    @QtCore.pyqtSlot(str)
    def _on_hotkey(self, s):
        self.hotkey_binding = s
        self.hot_label.setText(s)
        self.log_msg("Hotkey recorded: "+s)
        self._start_hot_listener()

    def _start_hot_listener(self):
        if getattr(self, "_hotstop", None): self._hotstop.set()
        self._hotstop = threading.Event()
        def listener():
            stop_event = self._hotstop
            if not getattr(self, "hotkey_binding", ""): return
            btype, bval = self.hotkey_binding.split(":",1)
            def on_k(key):
                if stop_event.is_set(): return False
                try:
                    name = key.char if hasattr(key, "char") and key.char else str(key).split(".")[-1]
                    if btype=="key" and name==bval:
                        QtCore.QMetaObject.invokeMethod(self, "_toggle_start_stop", QtCore.Qt.QueuedConnection)
                except: pass
            def on_m(x,y,button,pressed):
                if stop_event.is_set(): return False
                if not pressed: return
                if btype=="mouse" and str(button).split(".")[-1]==bval:
                    QtCore.QMetaObject.invokeMethod(self, "_toggle_start_stop", QtCore.Qt.QueuedConnection)
            kb = pynput_keyboard.Listener(on_press=on_k); ms = pynput_mouse.Listener(on_click=on_m)
            kb.start(); ms.start()
            while not stop_event.is_set():
                time.sleep(0.1)
            try: kb.stop(); ms.stop()
            except: pass
        threading.Thread(target=listener, daemon=True).start()

    @QtCore.pyqtSlot()
    def _toggle_start_stop(self):
        if self.btn_start.isEnabled(): self.start_clicker()
        else: self.stop_clicker()

    def start_clicker(self):
        try:
            interval = int(self.interval_edit.text())
            if interval < 1: raise ValueError()
        except:
            QtWidgets.QMessageBox.warning(self, "Start", "Interval must be integer >=1"); return
        self.clicker = SimpleClickerThread(interval); self.clicker.start()
        self.btn_start.setEnabled(False); self.btn_stop.setEnabled(True)
        self.log_msg("Simple clicker started")
        play_start_sound(self.parent().settings.get("sounds_enabled", True))
        LAST_SIMPLE_FILE.write_text(json.dumps({"interval_ms": interval, "hotkey": getattr(self, "hotkey_binding", "")}, ensure_ascii=False, indent=2), encoding="utf-8")
        if self.parent().hud:
            self.parent().hud.set_running(True, "Simple")

    def stop_clicker(self):
        if self.clicker:
            self.clicker.stop(); self.clicker = None
        self.btn_start.setEnabled(True); self.btn_stop.setEnabled(False)
        self.log_msg("Simple clicker stopped")
        play_stop_sound(self.parent().settings.get("sounds_enabled", True))
        if self.parent().hud:
            self.parent().hud.set_running(False)

    def refresh_profiles_list(self):
        self.profiles_list.clear()
        for n in list_profiles("simple"):
            self.profiles_list.addItem(n)

    def save_cfg(self):
        name, ok = QtWidgets.QInputDialog.getText(self, "Save profile", "Profile name:")
        if not ok or not name.strip(): return
        data = {"interval_ms": int(self.interval_edit.text()), "hotkey": getattr(self, "hotkey_binding", "")}
        save_profile("simple", name.strip(), data); self.log_msg("Saved profile "+name.strip()); self.refresh_profiles_list()

    def load_cfg(self):
        dlg = ProfilesDialog("simple", self, title="Load profile")
        if dlg.exec_() != QtWidgets.QDialog.Accepted: return
        name = dlg.selected(); 
        if not name: QtWidgets.QMessageBox.information(self,"Load","No profile selected"); return
        data = load_profile("simple", name)
        if not data: QtWidgets.QMessageBox.warning(self,"Load","Failed"); return
        self.interval_edit.setText(str(data.get("interval_ms", 200))); self.hotkey_binding = data.get("hotkey",""); self.hot_label.setText(self.hotkey_binding)
        self.log_msg("Loaded profile "+name); self.refresh_profiles_list(); self._start_hot_listener()

    def delete_cfg(self):
        dlg = ProfilesDialog("simple", self, title="Delete profile")
        if dlg.exec_() != QtWidgets.QDialog.Accepted: return
        name = dlg.selected()
        if not name: QtWidgets.QMessageBox.information(self,"Delete","No profile selected"); return
        delete_profile("simple", name); self.log_msg("Deleted profile "+name); self.refresh_profiles_list()

    def _load_last(self):
        last = load_json(LAST_SIMPLE_FILE, {})
        if last:
            try:
                self.interval_edit.setText(str(last.get("interval_ms", 200)))
                self.hotkey_binding = last.get("hotkey", ""); self.hot_label.setText(self.hotkey_binding)
            except: pass

# ---------- Settings widget ----------
class SettingsWidget(QtWidgets.QWidget):
    def __init__(self, mainwin):
        super().__init__()
        self.mainwin = mainwin
        self._build_ui()
        self.load_settings()

    def _build_ui(self):
        v = QtWidgets.QVBoxLayout(self)
        v.addWidget(QtWidgets.QLabel("<b>Settings</b>"))
        # theme selection (placeholder)
        h1 = QtWidgets.QHBoxLayout()
        self.theme_combo = QtWidgets.QComboBox(); self.theme_combo.addItems(["Dark (default)", "Light", "Neon"])
        h1.addWidget(QtWidgets.QLabel("Theme:")); h1.addWidget(self.theme_combo)
        v.addLayout(h1)
        # HUD opacity
        h2 = QtWidgets.QHBoxLayout()
        self.hud_opacity = QtWidgets.QSlider(QtCore.Qt.Horizontal); self.hud_opacity.setRange(20, 100); self.hud_opacity.setValue(85)
        h2.addWidget(QtWidgets.QLabel("HUD opacity:")); h2.addWidget(self.hud_opacity)
        v.addLayout(h2)
        # sounds
        h3 = QtWidgets.QHBoxLayout()
        self.sounds_cb = QtWidgets.QCheckBox("Enable start/stop sounds"); self.sounds_cb.setChecked(True)
        h3.addWidget(self.sounds_cb); h3.addStretch()
        v.addLayout(h3)
        # save button
        btn = QtWidgets.QPushButton("Save settings"); btn.clicked.connect(self.save_settings)
        v.addWidget(btn)
        v.addStretch()

    def load_settings(self):
        s = load_json(USER_SETTINGS, {})
        self.theme_combo.setCurrentIndex(0)
        if s:
            self.hud_opacity.setValue(s.get("hud_opacity", 85))
            self.sounds_cb.setChecked(s.get("sounds_enabled", True))

    def save_settings(self):
        s = load_json(USER_SETTINGS, {})
        s["hud_opacity"] = int(self.hud_opacity.value())
        s["sounds_enabled"] = bool(self.sounds_cb.isChecked())
        save_json(USER_SETTINGS, s)
        QtWidgets.QMessageBox.information(self, "Settings", "Settings saved.")
        # apply HUD opacity
        if self.mainwin.hud:
            self.mainwin.hud.setWindowOpacity(s["hud_opacity"]/100.0)

# ---------- Main application window ----------
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("GameHelper v3")
        self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        self.resize(920, 620)
        self.settings = load_json(USER_SETTINGS, {})
        self.hud = None
        self._build_ui()
        self.load_user_settings()

    def _build_ui(self):
        self.stack = QtWidgets.QStackedWidget()
        self.main_screen = MainScreen(self)
        self.window_widget = WindowClickerWidget()
        self.simple_widget = SimpleClickerWidget()
        self.settings_widget = SettingsWidget(self)
        self.stack.addWidget(self.main_screen); self.stack.addWidget(self.window_widget); self.stack.addWidget(self.simple_widget); self.stack.addWidget(self.settings_widget)
        self.setCentralWidget(self.stack)

        # hamburger menu custom
        self.hamburger = QtWidgets.QToolButton(); self.hamburger.setText("☰"); self.hamburger.setObjectName("hamburger")
        self.hamburger.setPopupMode(QtWidgets.QToolButton.InstantPopup)
        menu = QtWidgets.QMenu()
        menu.addAction("Главная", lambda: self.switch_to("main"))
        menu.addAction("Window Clicker", lambda: self.switch_to("window"))
        menu.addAction("Simple Clicker", lambda: self.switch_to("simple"))
        menu.addSeparator()
        menu.addAction("Refresh windows (window mode)", lambda: self.window_widget.refresh_windows())
        menu.addAction("Open configs folder", lambda: os.startfile(str(BASE_CONFIG_DIR)))
        menu.addSeparator()
        menu.addAction("Settings", lambda: self.switch_to("settings"))
        menu.addAction("Exit", lambda: QtWidgets.qApp.quit())
        self.hamburger.setMenu(menu)
        toolbar = QtWidgets.QToolBar(); toolbar.setMovable(False); toolbar.addWidget(self.hamburger)
        self.addToolBar(QtCore.Qt.TopToolBarArea, toolbar)

        # apply dark style
        self.setStyleSheet("""
            QWidget{ background:#0f1013; color:#e9eef8; font-family:Roboto, Segoe UI, Arial; }
            QLabel#title{ font-size:20pt; color:#fff; }
            QPushButton{ background: qlineargradient(x1:0,y1:0,x2:1,y2:0, stop:0 #4A90E2, stop:1 #357ABD); color:white; padding:6px; border-radius:6px; }
            QPushButton:disabled{ background:#333; color:#999; }
            QLineEdit, QPlainTextEdit, QListWidget{ background:#141417; border:1px solid #222; color:#e8eef8; }
            QComboBox{ background:#141417; color:#e8eef8; }
        """)

    def switch_to(self, name):
        if name=="main": self.stack.setCurrentWidget(self.main_screen)
        elif name=="window": self.stack.setCurrentWidget(self.window_widget)
        elif name=="simple": self.stack.setCurrentWidget(self.simple_widget)
        elif name=="settings": self.stack.setCurrentWidget(self.settings_widget)

    def create_hud_if_needed(self):
        if self.hud is None:
            self.hud = HudWindow()
            # load position & opacity from settings
            s = load_json(USER_SETTINGS, {})
            pos = s.get("hud_pos", None)
            if pos:
                try: self.hud.move(pos[0], pos[1])
                except: pass
            op = s.get("hud_opacity", 85)
            try: self.hud.setWindowOpacity(op/100.0)
            except: pass
            self.hud.show()
        else:
            self.hud.show()

    def load_user_settings(self):
        s = load_json(USER_SETTINGS, {})
        self.settings.update(s)
        # apply HUD opacity if HUD exists later
        if self.hud:
            self.hud.setWindowOpacity(self.settings.get("hud_opacity", 85)/100.0)

    def closeEvent(self, ev):
        # save HUD pos & opacity
        if self.hud:
            pos = (self.hud.x(), self.hud.y())
            op = int(self.hud.windowOpacity()*100)
            s = load_json(USER_SETTINGS, {})
            s["hud_pos"] = pos; s["hud_opacity"] = op
            save_json(USER_SETTINGS, s)
        # also save last-run states automatically via widgets
        ev.accept()

# ---------- Run ----------
def main():
    app = QtWidgets.QApplication(sys.argv)
    # set font to Roboto if available; otherwise fallback
    f = QtGui.QFont("Roboto", 10)
    app.setFont(f)
    w = MainWindow()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()